#include "Constants.h"
#include "TreeBuilder.h"
#include "TLConf.h"
#include "TMoteStackConf.h"

/** 
 * Dumb Building tree module. it should be mounted on the mobile node.
 * It's mainly remove the tuple form the TS generated by the tree
 *   builder component on the other motes.
 * It returns the parent as TL_NEIGHBORHOOD and pathCost and parentLQI 
 *   are equal to zero.
 *
 */
 
module DumbTreeBuilderP {

  uses {
    interface Boot;  
    interface Leds;
  }
  uses interface TupleSpace as TS;
  provides {  
    interface TreeConnection;
  }
}

#ifndef MOBILE_NODE
#warning "*** DUMB TREE ROUTING: THIS NODE IS GOING TO BE A MOBILE NODE ***"
#endif 

implementation {  
  TLOpId_t reactionId, ingId;

  event void Boot.booted() {
    tuple<uint8_t, uint16_t, uint16_t, uint16_t, uint32_t> p = newTuple(
                             actualField(TREE_BUILDING_MESSAGE),
                             dontCare(), 
                             dontCare(),
                             dontCare(),
                             dontCare());
    call TS.addReaction(&reactionId, FALSE, TL_LOCAL, RAM_TS, (tuple *) &p);
  }

  event void TS.tupleReady(TLOpId_t operationId, 
                           TupleIterator *iterator) {
    tuple<uint8_t, uint16_t, uint16_t, uint16_t, uint32_t>  t;
    tuple<uint8_t, uint16_t, uint16_t, uint16_t, uint32_t> *temp;
    
    PROCESS_OP(reactionId,
               temp = (tuple<uint8_t, uint16_t, uint16_t,
                       uint16_t, uint32_t> *) call TS.nextTuple(operationId, iterator);
               t = newTuple(
                            actualField(TREE_BUILDING_MESSAGE),
                            dontCare(),
                            dontCare(),
                            dontCare(),
                            dontCare());
               call TS.ing(&ingId, FALSE, TL_LOCAL, RAM_TS, (tuple *) &t);
              );

    /*     ING FOR THE TREEBUILD TUPLES */
    PROCESS_OP(ingId,
               for (temp = (tuple<uint8_t, uint16_t, uint16_t,
                            uint16_t, uint32_t> *) call TS.nextTuple(operationId, iterator);
                    temp != NULL;
                   ){
                 temp = (tuple<uint8_t, uint16_t, uint16_t,
                            uint16_t, uint32_t> *) call TS.nextTuple(operationId, iterator);
               }
              );
  }

  event void TS.reifyCapabilityTuple(tuple* ct) {
  }

  event void TS.operationCompleted(uint8_t completionCode, 
        TLOpId_t operationId, 
        TLTarget_t target,  
        TLTupleSpace_t ts,
        tuple* returningTuple){
  }


  command uint16_t TreeConnection.getParent(){
    return TL_NEIGHBORHOOD;
  }
  
  command uint16_t TreeConnection.getPathCost(){
    return 0;
  }

  command uint16_t TreeConnection.getParentLQI(){
    return 0;
  }


  command void TreeConnection.setSink(bool isSinkNode){
    return;
  }

  command uint32_t TreeConnection.getParentNextWakeUp(){
    return NODE_EVERY_UP;
  } 
}
