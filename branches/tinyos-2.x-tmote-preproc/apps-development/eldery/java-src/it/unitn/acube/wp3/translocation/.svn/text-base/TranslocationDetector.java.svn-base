/**
 * 
 */
package it.unitn.acube.wp3.translocation;

import it.unitn.acube.wp3.WSNEventsConsumer;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.apache.log4j.Logger;

/**
 * Class that buffers detection contacts and implements the translocation (i.e.
 * move from one room to another) detection.
 * 
 * A new location is determined only if the node does not oscillated for a give
 * time({@link STUTTER_TIMEOUT})
 * 
 * @author Stefan Guna
 * 
 */
public class TranslocationDetector {
	/**
	 * Abstracts a contact detected between a mobile node and an anchor node.
	 * 
	 * @author Stefan Guna
	 * 
	 */
	private class ContactEvent {
		/** The room where the anchor node is situated. */
		private Area location;
		/** The timestamp of the contact */
		private Date timestamp;

		public ContactEvent(Area location) {
			this.location = location;
			timestamp = new Date();
		}

		/**
		 * @return the location
		 */
		public Area getLocation() {
			return location;
		}

		/**
		 * @return the timestamp
		 */
		public Date getTimestamp() {
			return timestamp;
		}
	}

	public static Logger log = Logger.getLogger(TranslocationDetector.class
			.getName());

	/**
	 * This parameters determines the duration of the minimal stable period
	 * (i.e. the subject doesn't move from one room to another) before a
	 * resolution on the location of the subject can be given.
	 */
	private static final long STUTTER_TIMEOUT = 500;

	private List<WSNEventsConsumer> consumers;

	/** A history of contacts for each mobile node. */
	private HashMap<Integer, ArrayList<ContactEvent>> contacts;
	/** Description of the deployment. */
	private Deployment deployment;
	/** The last known location of each mobile nodes. */
	private HashMap<Integer, ContactEvent> lastLocations;

	/**
	 * Constructor of the translocation detection algorithm.
	 * 
	 * @param deployment
	 *            Descriptor of the deployment.
	 * @param consumers
	 *            List of consumers of events generated by this component.
	 * @see {@link Area}
	 */
	public TranslocationDetector(Deployment deployment,
			List<WSNEventsConsumer> consumers) {
		this.deployment = deployment;
		this.consumers = consumers;
		contacts = new HashMap<Integer, ArrayList<ContactEvent>>();
		lastLocations = new HashMap<Integer, ContactEvent>();
	}

	/**
	 * Drops all contact history for a give node.
	 * 
	 * @param node
	 *            The node of the mobile ID to flush its history.
	 * @param flushThreshold
	 *            The point in time for which all previous contacts are flushed.
	 */
	private void flushBefore(Integer node, ContactEvent flushThreshold) {
		ArrayList<ContactEvent> locations = contacts.get(node);
		Date flushPoint = flushThreshold.getTimestamp();
		log.trace("Flushing history for " + node + " before " + flushPoint
				+ " out of " + locations.size());
		while (locations.get(0).getTimestamp().before(flushPoint))
			locations.remove(0);
		log.trace(locations.size() + " left");
	}

	/**
	 * Returns the last known location of a mobile node
	 * 
	 * @param nodeId
	 *            The id of the node.
	 * @return String identifying the location.
	 */
	public String lastLocationCode(Integer nodeId) {
		ContactEvent event = lastLocation(nodeId);
		if (event == null)
			return null;
		return event.getLocation().getCode();
	}

	/**
	 * Returns the last know "stable" (i.e. that doesn't oscillate for
	 * {@link STUTTER_TIMEOUT}) location of a mobile node.
	 * 
	 * @param node
	 *            The mobile node to get location.
	 * @return the contact event denoting the last stable location, {@code null}
	 *         if there is no such contact detected.
	 */
	private ContactEvent lastLocation(Integer node) {
		ArrayList<ContactEvent> locations = contacts.get(node);
		Set<Area> locationHistory = new HashSet<Area>();

		if (locations == null)
			return null;

		for (int i = locations.size() - 1; i >= 0; i--) {
			ContactEvent pivot = locations.get(i);
			long pivotTS = pivot.getTimestamp().getTime();
			locationHistory.add(pivot.getLocation());

			for (int j = i - 1; j >= 0; j--) {
				ContactEvent tmp = locations.get(j);
				long tmpTS = tmp.getTimestamp().getTime();
				locationHistory.add(tmp.getLocation());

				if (pivotTS - tmpTS > STUTTER_TIMEOUT)
					return pivot;

				if (tmp.getLocation().equals(pivot.getLocation()))
					continue;

				i = j;
				break;
			}
		}
		if (locationHistory.size() == 1)
			return locations.get(locations.size() - 1);
		return null;
	}

	/**
	 * Register a contact between two nodes. One of the nodes must be an anchor
	 * node and the other node must be mobile.
	 * 
	 * @param node1
	 * @param node2
	 */
	public void registerContact(Integer node1, Integer node2) {
		Integer mobile = node2, fixed = node1;
		Area location = deployment.getArea(node1);
		if (location == null) {
			location = deployment.getArea(node2);
			fixed = node2;
			mobile = node1;
		}

		Area neighbor = location.getNeighbor(fixed);
		if (neighbor != null && neighbor.isHazard()) {
			log.info(deployment.getActor(mobile) + " close to hazard area "
					+ neighbor);
			for (WSNEventsConsumer consumer : consumers)
				consumer.proximity(deployment.getActor(mobile), neighbor
						.getParent().getCode(), neighbor.getCode());
		}

		ArrayList<ContactEvent> tmp = contacts.get(mobile);
		if (tmp == null) {
			tmp = new ArrayList<ContactEvent>();
			contacts.put(mobile, tmp);
		}
		tmp.add(new ContactEvent(location));

		log.trace(tmp.size() + " events for " + mobile);

		ContactEvent lastContact = lastLocation(mobile);
		if (lastContact == null) {
			log.debug("Unable to determine location");
			return;
		}

		Area lastRoom = lastContact.getLocation();

		if (lastLocations.get(mobile) == null) {
			log.debug("First location of " + mobile + " in " + lastRoom);
			lastLocations.put(mobile, lastContact);
			return;
		}

		if (!lastLocations.get(mobile).getLocation().equals(lastRoom)) {
			log
					.info(deployment.getActor(mobile) + " "
							+ lastLocations.get(mobile).getLocation() + "->"
							+ lastRoom);
			lastLocations.put(mobile, lastContact);
			Area from = lastLocations.get(mobile).getLocation();
			Area to = lastRoom;
			for (WSNEventsConsumer consumer : consumers)
				consumer.translocation(deployment.getActor(mobile), from
						.getCode(), to.getCode());
		} else
			log.debug("Node " + mobile + " still in " + lastRoom);
		flushBefore(mobile, lastContact);
	}
}
