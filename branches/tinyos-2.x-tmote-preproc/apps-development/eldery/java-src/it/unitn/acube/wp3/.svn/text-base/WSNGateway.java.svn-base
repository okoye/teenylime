/**
 * 
 */
package it.unitn.acube.wp3;

import it.unitn.acube.wp3.translocation.Deployment;
import it.unitn.acube.wp3.translocation.DeploymentBuilder;
import it.unitn.acube.wp3.translocation.TranslocationDetector;

import java.io.File;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;

import net.tinyos.message.Message;
import net.tinyos.message.MessageListener;
import net.tinyos.message.MoteIF;
import net.tinyos.packet.BuildSource;
import net.tinyos.packet.PhoenixSource;
import net.tinyos.util.Messenger;

import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;

/**
 * Represents a connection to a packet source. To instantiate an object for this
 * type, you must use the factory method {@link getGateway()}, which allows only
 * one instance per packet source.
 * -
 * @author Stefan Guna
 * 
 */
public class WSNGateway implements MessageListener, Messenger {

	private static Hashtable<String, WSNGateway> gatewayInstances = new Hashtable<String, WSNGateway>();

	public static Logger log = Logger.getLogger(WSNGateway.class.getName());
	
	private static int SIZE_DUPL_BUFFER = 10000;
	private static int nextElDuplBuffer;
	private int addressDuplBuffer[] = new int[SIZE_DUPL_BUFFER];
	private long seqDuplBuffer[]= new long[SIZE_DUPL_BUFFER];
	

	/**
	 * Factory method. Allows only one instance per packet source.
	 * 
	 * @return The instance of the WSNGateway handling a packet source.
	 */
	public static synchronized WSNGateway getGateway(String source,
			String deploymentFile) {
		if (gatewayInstances.get(source) == null)
			gatewayInstances
					.put(source, new WSNGateway(source, deploymentFile));
		return gatewayInstances.get(source);
	}

	public static void main(String[] args) {
		File logProperties = new File(ConfigParameters
				.getProperty("logger-configuration"));
		if (!logProperties.exists())
			BasicConfigurator.configure();
		else
			PropertyConfigurator.configure(logProperties.getPath());

		String deploymentFile = null;
		if (args.length > 0)
			deploymentFile = args[0];
		if (deploymentFile == null)
			deploymentFile = ConfigParameters
					.getProperty("deployment-descriptor");
		log
				.info("Using the deployment descriptor in '" + deploymentFile
						+ "'.");

		getGateway(ConfigParameters.getProperty("data-source"), deploymentFile);
	}

	/** A list of consumer of events generated by the network. */
	private List<WSNEventsConsumer> consumers;

	private Deployment deployment;

	private MoteIF mote;

	private TranslocationDetector translocationDetector;

	private WSNGateway(String source, String deploymentFile) {
		consumers = new ArrayList<WSNEventsConsumer>();

		for (int i=0;i<SIZE_DUPL_BUFFER;i++){
			addressDuplBuffer[i]=Integer.MIN_VALUE;
		}
		nextElDuplBuffer=0;
		
		try {
			deployment = DeploymentBuilder.readDeployment(deploymentFile);
			if (deployment == null)
				return;
			translocationDetector = new TranslocationDetector(deployment,
					consumers);
		} catch (Exception e) {
			log
					.error("Unable to read deployment configuration, so proximity will not be detected.");
			e.printStackTrace();
			log.equals(e.getMessage());
		}

		log.debug("Building phoenix on " + source);
		PhoenixSource phoenix = BuildSource.makePhoenix(source, this);

		mote = new MoteIF(phoenix);
		mote.registerListener(new SerialMessage(), this);
	}

	private String getActor(int nodeId) {
		if (deployment == null)
			return "Actor " + nodeId;
		return deployment.getActor(nodeId);
	}
	
	private boolean isADuplicate(int addressNode, long seqNumber) {
		for (int i=0;i<SIZE_DUPL_BUFFER;i++){
			if ((seqDuplBuffer[i]==seqNumber)&&(addressDuplBuffer[i]==addressNode)){
				return true;
			}
		}
		seqDuplBuffer[nextElDuplBuffer]=seqNumber;
		addressDuplBuffer[nextElDuplBuffer]=addressNode;
		if (nextElDuplBuffer<SIZE_DUPL_BUFFER){
			nextElDuplBuffer++;
		} else {
			nextElDuplBuffer=0;
		}
		return false;		
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see net.tinyos.util.Messenger#message(java.lang.String)
	 */
	public void message(String arg0) {
		log.debug(arg0);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see net.tinyos.message.MessageListener#messageReceived(int,
	 * net.tinyos.message.Message)
	 */
	public void messageReceived(int to, Message msg) {
		boolean invalidMsg=false;		
		if (!(msg instanceof SerialMessage))
			log.error("Invalid message received.");

		SerialMessage serialMsg = (SerialMessage) msg;
		
		//Check if the message is allready received and in this case discard it
		if (isADuplicate(serialMsg.get_node(),serialMsg.get_seqNumber())){
			return;
		}

		switch (serialMsg.get_type()) {
		case Constants.CONTACT_EVENT:
			processContact(serialMsg);
			break;
		case Constants.POSTURE_EVENT:
			processPosture(serialMsg);
			break;
		case Constants.BUTTON_EVENT:
			processButton(serialMsg);
			break;
		case Constants.SENSORS_EVENT:
			processSensors(serialMsg);
			break;
		default:
			log.error("Invalid message type received (" + serialMsg.get_type()
					+ ")");
			invalidMsg=true;
		}

		/* Uncomment this part if you want visualize the seqNumber of the message*/
		
		if (!invalidMsg){
			log.debug("Message: Src"+serialMsg.get_node()+", #"+serialMsg.get_seqNumber()+", Type"+serialMsg.get_type());	
		}
		
	}

	private void processContact(SerialMessage contactMsg) {
		int source = contactMsg.get_data_contact_node1();
		int peer = contactMsg.get_data_contact_node2();
		int rssiTmp = contactMsg.get_data_contact_rssi();
		short rssi = (short) (((short) rssiTmp) - 45);

		if (rssi == -45)
			log.debug("Contact " + source + " " + peer + " reply message");
		else
			log.debug("Contact " + source + " " + peer + " RSSI: " + rssi);

		if (translocationDetector != null)
			translocationDetector.registerContact(source, peer);
	}

	private void processPosture(SerialMessage postureMsg) {
		int source = postureMsg.get_node();
		short posture = postureMsg.get_data_posture_posture();
		switch (posture) {
		case Constants.FALL_OCCURED:
			log.info(getActor(source) + " took a fall.");
			if (translocationDetector != null)
				for (WSNEventsConsumer consumer : consumers)
					consumer.fall(getActor(source), translocationDetector
							.lastLocationCode(source));
			break;
		case Constants.IMMOBILITY_OCCURED:
			log.info(getActor(source) + " is immobile.");
			if (translocationDetector != null)
				for (WSNEventsConsumer consumer : consumers)
					consumer.immobile(getActor(source), translocationDetector
							.lastLocationCode(source));
			break;
		case Constants.REGULAR_POSITION_AFTER_FALL:
			log.info(getActor(source) + " is come bakt to a regular position.");
			if (translocationDetector != null)
				for (WSNEventsConsumer consumer : consumers)
					consumer.immobile(getActor(source), translocationDetector
							.lastLocationCode(source));
			break;
		}
	}

	private void processButton(SerialMessage buttonMsg) {
		int source = buttonMsg.get_node();
		log.info(getActor(source) + " has pressed the button.");
		//Put the translocationDetector's code here
	}

	private void processSensors(SerialMessage sensorsMsg) {
		int source = sensorsMsg.get_node();
		int temperature = sensorsMsg.get_data_sensors_temperature();
		log.debug("Sensors sample: Source " + source + ", Temperature " + temperature);
		//Put the translocationDetector's code here
	}

	public void registerConsumer(WSNEventsConsumer consumer) {
		consumers.add(consumer);
	}

	public void unregisterConsumer(WSNEventsConsumer consumer) {
		consumers.remove(consumer);
	}
}
